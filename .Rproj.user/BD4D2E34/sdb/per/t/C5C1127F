{
    "collab_server" : "",
    "contents" : "#' Measures for Comparing Clusterings\n#'\n#' Given two partitions \\eqn{C_1} and \\eqn{C_2}, it returns community comparison scores\n#' corresponding with a set of designated methods. Note that two label vectors should be\n#' of same length having either numeric or factor type.\n#'\n#'\n#' @name mclustcomp\n#' @aliases mclustcomp\n#' @section list of the methods:\n#' \\describe{\n#'   \\item{\\code{'adjrand'}}{\\href{https://en.wikipedia.org/wiki/Rand_index#Adjusted_Rand_index}{\"Adjusted Rand index\"}. See [1985.Hubert].}\n#'   \\item{\\code{'chisq'}}{\\href{https://en.wikipedia.org/wiki/Chi-squared_test}{\"Chi-squared coefficient\"}. See [2001.Mirkin].}\n#'   \\item{\\code{'f'}}{\"F-Meausre\". See [1999.Larsen].}\n#'   \\item{\\code{'fmi'}}{\\href{https://en.wikipedia.org/wiki/Fowlkes-Mallows_index}{\"Fowlkes-Mallows index\"}. See [1983.Fowlkes].}\n#'   \\item{\\code{'jaccard'}}{\\href{https://en.wikipedia.org/wiki/Jaccard_index}{\"Jaccard index\"}. See [1901.Jaccard].}\n#'   \\item{\\code{'mhm'}}{\"Meila-Heckerman Measure\". See [2001.Meila].}\n#'   \\item{\\code{'mirkin'}}{\"Mirkin Metric\", also known as \"Equivalence Mismatch Distance\". See [2000.van Dongen].}\n#'   \\item{\\code{'mmm'}}{\"Maximum-Match Measure\". See [2006.Meila].}\n#'   \\item{\\code{'nmi1'}}{\\href{https://en.wikipedia.org/wiki/Mutual_information#Normalized_variants}{\"Normalized Mutual Information\"} by Strehl and Ghosh. See [2003.Strehl].}\n#'   \\item{\\code{'nmi2'}}{\\href{https://en.wikipedia.org/wiki/Mutual_information#Normalized_variants}{\"Normalized Mutual Information\"} by Fred and Jain. See [2003.Fred].}\n#'   \\item{\\code{'overlap'}}{\\href{https://en.wikipedia.org/wiki/Overlap_coefficient}{\"Overlap coefficient\"}. Also called as \"Szymkiewicz-Simpson coefficient\". See [1934.Szymkiewicz].}\n#'   \\item{\\code{'pd'}}{\"Partition Difference\". See [2004.Li].}\n#'   \\item{\\code{'rand'}}{\\href{https://en.wikipedia.org/wiki/Rand_index}{\"Rand index\"}. See [1971.Rand].}\n#'   \\item{\\code{'sdc'}}{\\href{https://en.wikipedia.org/wiki/Sorensen-Dice_coefficient}{\"Sørensen–Dice coefficient\"}. Also known as \"Sørensen index\", \"F1 score\" or \"Dice's coefficient\". See [1948.Sørensen].}\n#'   \\item{\\code{'smc'}}{\\href{https://en.wikipedia.org/wiki/Simple_matching_coefficient}{\"Simple Matching Coefficient\"}. See [2007.Segaran].}\n#'   \\item{\\code{'tanimoto'}}{\\href{https://en.wikipedia.org/wiki/Jaccard_index#Tanimoto_similarity_and_distance}{\"Tanimoto index\"}. See [1958.Tanimoto].}\n#'   \\item{\\code{'tversky'}}{\\href{https://en.wikipedia.org/wiki/Tversky_index}{\"Tversky index\"}. Tanimoto coefficient (\\code{'tanimoto'}) and Dice's coefficient (\\code{'sdc'}) are special cases of Tversky index\n#'   when (alpha,beta) = (1,1) and (0.5,0.5), respectively. See [1977.Tversky].}\n#'   \\item{\\code{'vdm'}}{\"van Dongen measure\". See [2000.van Dongen].}\n#'   \\item{\\code{'vi'}}{\\href{https://en.wikipedia.org/wiki/Variation_of_information}{\"Variation of Information\"}. See [2003.Kraskov].}\n#' }\n#' @references [1901.Jaccard] Jaccard, P. (1901) \\emph{Étude comparative de la distribution florale dans une portion des Alpes et des Jura.} Bulletin de la Société Vaudoise des Sciences Naturelles, 37:547-579.\n#' @references [1934.Szymkiewicz] Szymkiewicz, D. (1934) \\emph{Une contribution statistique a la geographie floristique.} Acta Societatis Botanicorum Poloniae, Vol.34(3):249-265.\n#' @references [1948.Sørensen] Sørensen, T. (1948) \\emph{A method of establishing groups of equal amplitude in plant sociology based on similarity of species and its application\n#' to analyses of the vegetation on Danish commons.} Kongelige Danske Videnskabernes Selskab, Vol.5(4):1-34.\n#' @references [1958.Tanimoto] Tanimoto, T. (1958) \\emph{An Elementary Mathematical theory of Classification and Prediction.} Internal IBM Technical Report.\n#' @references [1971.Rand] Rand, W.M. (1971) \\emph{Objective criteria for the evaluation of clustering methods.} Journal of the American Statistical Association, Vol.66(336):846-850.\n#' @references [1977.Tversky] Tversky, A. (1977) \\emph{Features of Similarity.} Psychological Reviews, Vol.84(4):327-352.\n#' @references [1983.Fowlkes] Fowlkes, E. B. and Mallows, C. L. (1983) \\emph{A Method for Comparing Two Hierarchical Clusterings.} Journal of the American\n#' Statistical Association, Vol.78(383):553-569.\n#' @references [1985.Hubert] Hubert, L. and Arabie, P. (1985) \\emph{Comparing partitions}. Journal of Classification, Vol.2(1):193-218.\n#' @references [1999.Larsen] Larsen, B. and Aone, C. (1999) \\emph{Fast and effective text mining using linear-time document clustering.}\n#' Proceedings of the fifth ACM SIGKDD international conference on Knowledge discovery and data mining, 16-22.\n#' @references [2000.van Dongen] van Dongen, S. (2000) \\emph{Performance Criteria for Graph Clustering and Markov Cluster Experiment}. Centrum voor Wiskunde en Informatica,\n#' Technical Report INS-R0012.\n#' @references [2001.Meila] Meila, M. and Heckerman, D. (2001) \\emph{An Experimental Comparison of Model-Based Clustering Methods}. Machine Learning, Vol.42(1-2):9-29.\n#' @references [2001.Mirkin] Mirkin, B. (2001) \\emph{Eleven Ways to Look at the Chi-Squared Coefficient for Contingency Tables}. The American Statistician, Vol.55(2):111-120.\n#' @references [2003.Fred] Fred, A. L.N. and Jain, A. K. (2003) \\emph{Robust Data Clustering.} Proceedings of IEEE Computer Society Conference on Computer Vision\n#' and Pattern Recognition, CVPR, (3):128-136.\n#' @references [2003.Kraskov] Kraskov, A., Stögbauer, H., Andrzejak, R.G., and Grassberger, P. (2003) \\emph{Hierarchical Clustering Based on Mutual Information.} arXiv:q-bio/0311039.\n#' @references [2003.Strehl] Strehl, A. and Ghosh, J. (2003) \\emph{Cluster ensembles - a knowledge reuse framework for combining multiple partitions.} The Journal of Machine Learning Research, Vol.3:583-617.\n#' @references [2004.Li] Li, T., Ogihara, M., and Ma, S. (2004) \\emph{On combining multiple clusterings.} Proceedings of the thirteenth ACM international conference on Information and knowledge management, 294-303.\n#' @references [2006.Meila] Meila, M. (2006) \\emph{Comparing clusterings-an information based distance.} Journal of Multivariate Analysis, Vol.98(5):873-895.\n#' @references [2007.Segaran] Segaran, T. (2007) \\emph{Programming Collective Intelligence.} O'Reilly Media, ISBN-10:0596529325.\n#'\n#' @param x,y vectors of clustering labels\n#' @param type.out \\code{\"all\"} for returning scores for every available measure.\n#' Either a single score name or a vector of score names can be supplied. See the section\n#' for the list of the methods for details.\n#' @param tversky.param a list of parameters for Tversky index; \\code{alpha} and \\code{beta} for\n#' weight parameters, and \\code{sym}, a logical where \\code{FALSE} stands for original method, \\code{TRUE}\n#' for a revised variant to symmetrize the score. Default (alpha,beta)=(1,1).\n#'\n#' @return a data frame where each element is a score in accordance with a name of the method as a key.\n#'\n#' @examples\n#' ## example 1. compare two identical clusterings\n#' x = sample(1:5,10,replace=TRUE) # label from 1 to 5, 10 elements\n#' y = x                           # set two labels x and y equal\n#' mclustcomp(x,y)                 # show all results\n#'\n#' ## example 2. selection of a few methods\n#' z = sample(1:4,10,replace=TRUE)           # generate a non-trivial clustering\n#' cmethods = c(\"jaccard\",\"tanimoto\",\"rand\") # select 3 methods\n#' mclustcomp(x,z,type.out=cmethods)         # test with the selected scores\n#'\n#' ## example 3. tversky.param\n#' tparam = list()                           # create an empty list\n#' tparam$alpha = 2\n#' tparam$beta  = 3\n#' tparam$sym   = TRUE\n#' mclustcomp(x,z,type.out=\"tversky\")        # default set as Tanimoto case.\n#' mclustcomp(x,z,type.out=\"tversky\",tversky.param=tparam)\n#'\n#' @export\nmclustcomp <- function(x,y,type.out=\"all\",tversky.param=list()){\n  ## Preprocessing : size argument\n  n = length(x)\n  if (length(y)!=n){\n    stop(\"* mclustcomp : two vectors should be of same size.\")\n  }\n  ## Preprocessing : Type conversion & unique vector\n  if (is.factor(x)){x = as.numeric(x)}\n  if (is.factor(y)){y = as.numeric(y)}\n  x=round(x); ux=unique(x);\n  y=round(y); uy=unique(y);\n  ## Preprocessing : ... : tversky parameter\n  listdot = as.list(environment())\n  if (\"tversky.param\" %in% names(listdot)){\n    tversky.param = listdot$tversky.param\n  } else {\n    tversky.param = list()\n  }\n  if (!(\"alpha\" %in% names(tversky.param))){tversky.param$alpha = 1}\n  if (!(\"beta\" %in% names(tversky.param))){tversky.param$beta = 1}\n  if (!(\"sym\" %in% names(tversky.param))){tversky.param$sym = FALSE}\n  if (tversky.param$alpha < 0){stop(\"* mclustcomp : tversky.param$alpha should be >= 0.\")}\n  if (tversky.param$beta < 0){stop(\"* mclustcomp : tversky.param$beta should be >= 0.\")}\n  if (!is.logical(tversky.param$sym)){stop(\"* mclustcomp : tversky.param$sym should\n                                           be a logical variable; FALSE for original Tversky index, TRUE for a variant.\")}\n\n\n  ## Prelim1 : CONFUSION MATRIX of size(length(ux),length(uy))\n  confmat = get.confusion(x,y,ux,uy)\n  ## Prelim2 : size of each cluster\n  scx = get.commsize(x,ux)\n  scy = get.commsize(y,uy)\n  ## Prelim3 : comembership matrix of (2,2)\n  pairmat = get.pair(x,y)\n  ## Prelim4 : probability-related stuffs for Mutual Information\n  threps = min(1e-10,.Machine$double.eps)\n  probs  = get.probs(confmat,scx,scy,n,threps)\n\n  ## Control : type.out\n  ## Case 1  : Single Argument\n  ##  {\"all\" or single name}\n  ## Case 2  : a vector of names; c(\"f\",\"rand\")\n  type.allnames = c(\"adjrand\",\"chisq\",\"f\",\"fmi\",\"jaccard\",\"mhm\",\"mirkin\",\"mmm\",\"nmi1\",\"nmi2\",\"overlap\",\"pd\",\"rand\",\"sdc\",\"smc\",\"tanimoto\",\"tversky\",\"vdm\",\"vi\")\n  type.out   = unique(type.out)\n  if (\"all\" %in% type.out){\n    type.test = type.allnames\n  } else {\n    type.test = type.out  # this type test is the one we should generate again\n  }\n\n  ## Main Computation\n  ## (\"adjrand\",\"chisq\",\"f\",\"fmi\",\"jaccard\",\"mhm\",\"mirkin\",\"mmm\",\"nmi1\",\"nmi2\",\"overlap\",\"pd\",\"rand\",\"sdc\",\"smc\",\"tanimoto\",\"tversky\",\"vdm\",\"vi\")\n  type.score = array(0,c(1,length(type.test)))\n  for (i in 1:length(type.test)){\n    type.score[i] = mclustsingle(n,x,y,ux,uy,scx,scy,confmat,pairmat,probs,threps,type.test[i],tversky.param)\n  }\n\n  ## Return results\n  result = data.frame(type.score)\n  colnames(result) = type.test\n  orderres = order(names(result)) # reordering by names\n  result = result[orderres]\n\n  return(result)\n}\n\n\n\n# COMPUTE :: single measure branching -------------------------------------\n## Original Implementation of 19 methods\nmclustsingle <- function(n,x,y,ux,uy,scx,scy,confmat,pairmat,probs,threps,type,tversky.param){\n  # Missing parameters for score08_mmm\n  nk = length(scx)\n  nl = length(scy)\n  # Sepearting probs for NMI and VIs\n  Ixy = probs$Ixy\n  Hx  = probs$Hx\n  Hy  = probs$Hy\n  # Tversky parameter\n  t.alpha = tversky.param$alpha\n  t.beta  = tversky.param$beta\n  t.sym   = tversky.param$sym\n\n  switch(type,\n         \"adjrand\"  = {output = score01_adjrand(confmat,scx,scy,n)},\n         \"chisq\"    = {output = score02_chisq(confmat,scx,scy,n)},\n         \"f\"        = {output = score03_f(scx,scy,n)},\n         \"fmi\"      = {output = score04_fmi(pairmat)},\n         \"jaccard\"  = {output = score05_jaccard(pairmat)},\n         \"mhm\"      = {output = score06_mhm(confmat,n)},\n         \"mirkin\"   = {output = score07_mirkin(confmat,scx,scy)},\n         \"mmm\"      = {output = score08_mmm(confmat,n,nk,nl)},\n         \"nmi1\"     = {output = score09_nmi1(Ixy,Hx,Hy,threps)},\n         \"nmi2\"     = {output = score10_nmi2(Ixy,Hx,Hy,threps)},\n         \"overlap\"  = {output = score11_overlap(pairmat)},\n         \"pd\"       = {output = score12_pd(pairmat)},\n         \"rand\"     = {output = score13_rand(pairmat,n)},\n         \"sdc\"      = {output = score14_sdc(pairmat)},\n         \"smc\"      = {output = score15_smc(pairmat)},\n         \"tanimoto\" = {output = score17_tversky(pairmat,1,1,FALSE)},\n         \"tversky\"  = {output = score17_tversky(pairmat,t.alpha,t.beta,t.sym)},\n         \"vdm\"      = {output = score18_vdm(confmat,n)},\n         \"vi\"       = {output = score19_vi(Ixy,Hx,Hy,threps)}\n         )\n  # return output\n  return(output)\n}\n",
    "created" : 1504909605011.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "4113852938",
    "id" : "C5C1127F",
    "lastKnownWriteTime" : 1505121507,
    "last_content_update" : 1505121507749,
    "path" : "~/Dropbox/Etc_Develop/R_mclustcomp/ver_0.1.0/mclustcomp/R/mclustcomp.R",
    "project_path" : "R/mclustcomp.R",
    "properties" : {
        "tempName" : "Untitled1"
    },
    "relative_order" : 4,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}